# 2단계: 고급 기능 및 API

## 4. 팔로우 기능

사용자 간의 관계를 형성하는 팔로우/언팔로우 기능을 구현합니다. 이를 위해 `Follow` 엔티티를 설계하고 관련 비즈니스 로직과 API를 만듭니다.

### 1. `Follow` 엔티티

두 사용자 간의 팔로우 관계를 나타내는 엔티티입니다.

- `fromUser`: 팔로우를 하는 사용자 (주체)
- `toUser`: 팔로우를 당하는 사용자 (대상)
- `@ManyToOne`: `UserAccount`와 다대일 관계를 맺습니다.
- `@Table(uniqueConstraints = ...)`: `fromUser`와 `toUser`의 조합이 유일하도록 데이터베이스에 `UNIQUE` 제약조건을 설정하여 중복 팔로우를 방지합니다.

```java
// src/main/java/com/example/boardpjt/model/entity/Follow.java

package com.example.boardpjt.model.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(uniqueConstraints = {
        @UniqueConstraint(columnNames = {"from_user_id", "to_user_id"})
})
public class Follow {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "from_user_id")
    private UserAccount fromUser;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "to_user_id")
    private UserAccount toUser;
}
```

### 2. `FollowRepository`

`Follow` 엔티티에 대한 데이터베이스 작업을 처리합니다.

- `existsByFromUserAndToUser()`: 특정 사용자가 다른 사용자를 이미 팔로우하고 있는지 여부를 확인합니다.
- `findByFromUserAndToUser()`: 팔로우 관계를 조회하여 삭제 시 사용합니다.
- `countByToUser()`: 특정 사용자를 팔로우하는 사람의 수(팔로워 수)를 계산합니다.
- `countByFromUser()`: 특정 사용자가 팔로우하는 사람의 수(팔로잉 수)를 계산합니다.

```java
// src/main/java/com/example/boardpjt/model/repository/FollowRepository.java

package com.example.boardpjt.model.repository;

import com.example.boardpjt.model.entity.Follow;
import com.example.boardpjt.model.entity.UserAccount;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface FollowRepository extends JpaRepository<Follow, Long> {
    boolean existsByFromUserAndToUser(UserAccount fromUser, UserAccount toUser);
    Optional<Follow> findByFromUserAndToUser(UserAccount fromUser, UserAccount toUser);
    long countByToUser(UserAccount toUser); // 팔로워 수
    long countByFromUser(UserAccount fromUser); // 팔로잉 수
}
```

### 3. `FollowService`

팔로우/언팔로우 비즈니스 로직을 처리합니다.

- **`follow()`**: 팔로우 요청을 처리합니다.
  - `fromUser`와 `toUser`의 `UserAccount` 엔티티를 조회합니다.
  - 자기 자신을 팔로우하려는 경우 예외를 발생시킵니다.
  - `followRepository.existsBy...()`를 통해 이미 팔로우 관계인지 확인하고, 중복 요청 시 예외를 발생시킵니다.
  - 새로운 `Follow` 엔티티를 생성하고 저장합니다.
- **`unfollow()`**: 언팔로우 요청을 처리합니다.
  - `followRepository.findBy...()`를 통해 팔로우 관계를 조회하고, 존재하지 않으면 예외를 발생시킵니다.
  - 조회된 `Follow` 엔티티를 삭제합니다.
- **`getFollowStatus()`**: 팔로우 상태와 팔로워/팔로잉 수를 조회합니다.
  - 현재 로그인한 사용자가 특정 사용자를 팔로우하고 있는지 여부를 확인합니다.
  - 대상 사용자의 팔로워 수와 팔로잉 수를 계산하여 DTO로 반환합니다.

```java
// src/main/java/com/example/boardpjt/service/FollowService.java

@Service
@RequiredArgsConstructor
@Transactional
public class FollowService {

    private final FollowRepository followRepository;
    private final UserAccountRepository userAccountRepository;

    public void follow(String fromUsername, String toUsername) {
        UserAccount fromUser = findUser(fromUsername);
        UserAccount toUser = findUser(toUsername);

        if (fromUser.equals(toUser)) {
            throw new IllegalArgumentException("자기 자신을 팔로우할 수 없습니다.");
        }
        if (followRepository.existsByFromUserAndToUser(fromUser, toUser)) {
            throw new IllegalArgumentException("이미 팔로우하고 있습니다.");
        }

        Follow follow = new Follow();
        follow.setFromUser(fromUser);
        follow.setToUser(toUser);
        followRepository.save(follow);
    }

    public void unfollow(String fromUsername, String toUsername) {
        UserAccount fromUser = findUser(fromUsername);
        UserAccount toUser = findUser(toUsername);

        Follow follow = followRepository.findByFromUserAndToUser(fromUser, toUser)
                .orElseThrow(() -> new IllegalArgumentException("팔로우 관계가 아닙니다."));
        followRepository.delete(follow);
    }

    @Transactional(readOnly = true)
    public FollowStatusDto getFollowStatus(String fromUsername, String toUsername) {
        UserAccount fromUser = findUser(fromUsername);
        UserAccount toUser = findUser(toUsername);

        boolean isFollowing = followRepository.existsByFromUserAndToUser(fromUser, toUser);
        long followersCount = followRepository.countByToUser(toUser);
        long followingCount = followRepository.countByFromUser(toUser);

        return new FollowStatusDto(isFollowing, followersCount, followingCount);
    }

    private UserAccount findUser(String username) {
        return userAccountRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username));
    }
}

// 팔로우 상태를 전달할 DTO
public record FollowStatusDto(boolean isFollowing, long followersCount, long followingCount) {}
```

### 4. `FollowApiController`

팔로우/언팔로우 요청을 처리하는 REST API 컨트롤러입니다.

- **`follow()`**: `POST /api/v1/follow/{username}`
  - 현재 로그인한 사용자가 `{username}`을 팔로우합니다.
- **`unfollow()`**: `DELETE /api/v1/follow/{username}`
  - 현재 로그인한 사용자가 `{username}`을 언팔로우합니다.
- **`getStatus()`**: `GET /api/v1/follow/{username}/status`
  - 현재 로그인한 사용자와 `{username}` 간의 팔로우 상태 및 팔로워/팔로잉 수를 조회합니다.

```java
// src/main/java/com/example/boardpjt/controller/FollowApiController.java

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/follow")
public class FollowApiController {

    private final FollowService followService;

    @PostMapping("/{username}")
    public ResponseEntity<Void> follow(@PathVariable String username, @AuthenticationPrincipal UserDetails userDetails) {
        followService.follow(userDetails.getUsername(), username);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{username}")
    public ResponseEntity<Void> unfollow(@PathVariable String username, @AuthenticationPrincipal UserDetails userDetails) {
        followService.unfollow(userDetails.getUsername(), username);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/{username}/status")
    public ResponseEntity<FollowStatusDto> getStatus(@PathVariable String username, @AuthenticationPrincipal UserDetails userDetails) {
        FollowStatusDto status = followService.getFollowStatus(userDetails.getUsername(), username);
        return ResponseEntity.ok(status);
    }
}
```

### 5. 프론트엔드 연동

사용자 프로필 페이지나 게시글 상세 페이지 등에서 팔로우 버튼을 추가하고, JavaScript를 사용하여 비동기적으로 팔로우/언팔로우 기능을 처리합니다.

- **UI**: 팔로우/언팔로우 버튼과 팔로워/팔로잉 수를 표시할 영역을 만듭니다.
- **JavaScript**:
  - 페이지 로드 시 `GET /api/v1/follow/{username}/status`를 호출하여 초기 상태(팔로우 여부, 팔로워/팔로잉 수)를 가져와 UI에 반영합니다.
  - 팔로우 버튼 클릭 시 `isFollowing` 상태에 따라 `POST` 또는 `DELETE` 요청을 보냅니다.
  - 요청 성공 시 UI(버튼 텍스트, 팔로워 수 등)를 즉시 업데이트하여 사용자에게 피드백을 줍니다.

이것으로 2단계의 핵심 기능인 댓글과 팔로우 기능 구현이 완료되었습니다. 다음 3단계에서는 프로젝트를 실제 운영 환경에 배포하는 방법을 다룹니다.
