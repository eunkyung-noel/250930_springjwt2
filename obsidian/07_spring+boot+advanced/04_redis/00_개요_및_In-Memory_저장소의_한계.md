# 00 개요 및 In-Memory 저장소의 한계

#개요 #InMemory #인메모리

## In-Memory 저장소의 명확한 한계

이번 실습에서는 Refresh Token을 서버의 메모리(단순 `Map`)에 저장합니다. 이는 개념 학습에는 용이하지만, 실제 운영 환경에서는 절대 사용하면 안 됩니다.

- **휘발성 (Volatility)**: 애플리케이션을 재시작하면 메모리에 저장된 모든 Refresh Token이 사라짐. 모든 사용자는 강제로 로그아웃 처리됨.
- **확장성 부재 (No Scalability)**: 여러 서버 인스턴스로 로드 밸런싱(Scale-out) 시, 토큰이 저장된 서버와 요청을 받은 서버가 다를 수 있어 인증 불일치 발생.
  - 예: 1번 서버에서 로그인 후, 재발급 요청이 2번 서버로 가면 2번 서버는 해당 Refresh Token을 알지 못함.

👉 이러한 한계점 때문에 다음 장에서 고성능 인메모리 데이터 저장소인 Redis를 도입하여 문제를 해결할 것입니다.

## Redis란?

#Redis #레디스

- **REmote DIctionary Server**의 약자로, In-Memory(인메모리) 기반의 Key-Value 데이터 저장소입니다.
- 모든 데이터를 메모리에 저장하여 디스크 기반의 데이터베이스(MySQL, PostgreSQL 등)보다 월등히 빠른 읽기/쓰기 속도를 제공합니다.
- 단순한 Key-Value 외에도 Lists, Sets, Hashes 등 다양한 자료구조를 지원하여 캐시, 세션 저장소, 메시지 큐 등 다용도로 활용됩니다.

## Refresh Token 저장소로서 Redis의 특징과 이점

In-Memory `Map` 대비 Redis가 가지는 압도적인 이점은 다음과 같습니다.

- ✔️ **영속성 (Persistence)**
  - **문제점**: 기존 In-Memory 방식은 서버를 재시작하면 모든 토큰 정보가 사라져 사용자들이 강제로 로그아웃되었습니다.
  - **Redis 해결**: Redis는 메모리의 데이터를 주기적으로 디스크에 저장하는 스냅샷, AOF(Append Only File) 기능을 제공합니다. 이를 통해 서버 장애나 재시작 시에도 데이터를 복구하여 사용자 로그인 상태를 유지할 수 있습니다.
- ✔️ **확장성 (Scalability)**
  - **문제점**: 트래픽 증가로 서버를 여러 대로 늘리면(Scale-out), 각 서버는 자신만의 메모리(Map)를 가지므로 1번 서버에서 발급된 토큰을 2번 서버에서 검증할 수 없었습니다.
  - **Redis 해결**: 모든 서버 인스턴스가 하나의 중앙 Redis 저장소를 공유합니다. 어떤 서버로 요청이 들어오든 동일한 데이터에 접근할 수 있어, 로드 밸런싱 환경에서 상태 정보(Refresh Token)를 일관되게 관리할 수 있습니다.
- ✔️ **자동 만료 처리 (TTL: Time To Live)**
  - **개선점**: 기존에는 토큰 재발급 시 `jwtUtil.isExpired()`로 만료 여부를 직접 확인해야 했습니다.
  - **Redis 해결**: Redis에 데이터를 저장할 때 **만료 시간(TTL)**을 함께 설정할 수 있습니다. 지정된 시간이 지나면 Redis가 자동으로 해당 데이터를 삭제해줍니다. 이는 만료된 토큰이 저장소에 불필요하게 쌓이는 것을 방지하고, 코드의 복잡도를 낮춰줍니다.
