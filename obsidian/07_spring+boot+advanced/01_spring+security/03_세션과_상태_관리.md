# 세션과 쿠키를 이용한 상태 관리

HTTP 프로토콜은 본질적으로 **무상태(Stateless)**입니다. 즉, 서버는 각 클라이언트의 요청을 독립적인 것으로 취급하며 이전 요청의 내용을 기억하지 못합니다. 하지만 "로그인 유지", "장바구니"와 같은 기능을 구현하려면 여러 요청에 걸쳐 사용자의 정보를 기억해야 할 필요가 있습니다. 이를 **상태 관리(State Management)**라고 합니다.

상태 관리를 위한 대표적인 기술이 바로 **세션(Session)**과 **쿠키(Cookie)**입니다.

---

## 1. 상태 유지(Stateful) vs 무상태(Stateless)

| 구분               | 상태 유지 (Stateful) - 세션 기반                                                                                                                                                                                                                                                                                        | 무상태 (Stateless) - 토큰 기반 (예: JWT)                                                                                                                                                                                                                                                                   |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **상태 저장 위치** | **서버** (메모리, DB, 외부 세션 스토리지 등)                                                                                                                                                                                                                                                                            | **클라이언트** (토큰 자체에 사용자 정보 포함)                                                                                                                                                                                                                                                              |
| **작동 방식**      | 1. 로그인 성공 시 서버가 **세션 ID**를 생성하고, 세션 저장소에 사용자 정보를 저장합니다.<br>2. 서버는 클라이언트에게 세션 ID를 쿠키(`JSESSIONID`)로 전달합니다.<br>3. 클라이언트는 이후 모든 요청에 세션 ID 쿠키를 담아 보냅니다.<br>4. 서버는 세션 ID를 통해 세션 저장소에서 사용자 정보를 조회하여 상태를 확인합니다. | 1. 로그인 성공 시 서버가 사용자 정보를 담은 **토큰**을 생성하고 서명합니다.<br>2. 서버는 토큰을 클라이언트에게 전달합니다.<br>3. 클라이언트는 이후 모든 요청의 헤더(예: `Authorization: Bearer ...`)에 토큰을 담아 보냅니다.<br>4. 서버는 토큰의 서명을 검증하여 사용자 정보를 신뢰하고 상태를 확인합니다. |
| **장점**           | - 중요한 사용자 정보(권한 등)를 서버에 안전하게 보관할 수 있습니다.<br>- 서버에서 특정 사용자의 세션을 강제로 만료시키는 등 세션 제어가 용이합니다.                                                                                                                                                                     | - 서버의 확장성(Scale-out)에 유리합니다. 각 서버가 상태를 저장할 필요가 없어 세션 동기화 문제가 발생하지 않습니다.<br>- 모바일 앱, 다른 도메인의 웹 서비스 등 다양한 클라이언트 환경에서 사용하기 편리합니다.                                                                                              |
| **단점**           | - 서버에 부하가 발생하고 추가적인 저장 공간이 필요합니다.<br>- 여러 서버로 확장할 경우, 모든 서버가 세션 정보를 공유해야 하는 **세션 동기화(Session Clustering)** 문제가 발생할 수 있습니다.                                                                                                                            | - 토큰에 담을 수 있는 정보의 양이 제한적입니다.<br>- 한 번 발급된 토큰은 만료 시간 전까지 제어하기 어렵습니다. (토큰을 강제 로그아웃 시키려면 서버 측에 별도의 블랙리스트 관리 필요)                                                                                                                       |

---

## 2. 세션을 이용한 상태 관리

세션은 서버 측에서 사용자의 상태를 관리하는 핵심 기술입니다. Spring Security는 기본적으로 이 세션 방식을 사용하여 인증된 사용자의 정보를 유지합니다.

### 2.1. Spring Security의 자동 세션 관리

Spring Security는 `SecurityFilterChain` 설정을 통해 세션 관리 정책을 손쉽게 제어할 수 있습니다.

**`sessionManagement` DSL 설정 예시**:

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .sessionManagement(session -> session
            // 1. 세션 생성 정책 설정 (기본값: IF_REQUIRED)
            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
            // 2. 동시 세션 제어 (한 사용자당 하나의 세션만 허용)
            .maximumSessions(1)
                .maxSessionsPreventsLogin(true) // 새로운 로그인 차단
        );
    // ...
}
```

- **`SessionCreationPolicy`**:
  - `IF_REQUIRED` (기본값): Spring Security가 필요하다고 판단할 때만 세션을 생성합니다. (예: 사용자가 로그인할 때)
  - `STATELESS`: 세션을 전혀 사용하지 않습니다. JWT와 같은 토큰 기반 인증 시 사용합니다.

**로그아웃과 세션 무효화**:
`logout` DSL을 사용하면 로그아웃 시 세션을 자동으로 파기할 수 있습니다.

```java
http
    .logout(logout -> logout
        .logoutUrl("/logout")
        .invalidateHttpSession(true) // HTTP 세션을 무효화 (기본값: true)
        .deleteCookies("JSESSIONID") // JSESSIONID 쿠키 삭제
    );
```

### 2.2. HTTP 세션 직접 다루기

Spring Security의 자동화 기능 외에, '방문 횟수 추적'이나 '장바구니'처럼 애플리케이션 고유의 데이터를 세션에 직접 저장하고 싶을 때도 있습니다.

**`HttpSession` 사용 예시 (방문 횟수 추적)**:

```java
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.SessionAttribute;

@Controller
public class SessionController {

    @GetMapping("/visit")
    public String trackVisit(
        HttpSession session,
        @SessionAttribute(name = "visitCount", required = false) Integer visitCount,
        Model model
    ) {
        if (visitCount == null) {
            visitCount = 1;
        } else {
            visitCount++;
        }
        session.setAttribute("visitCount", visitCount);

        model.addAttribute("count", visitCount);
        return "visit-count";
    }
}
```

- `request.getSession(true)` 또는 컨트롤러 파라미터로 `HttpSession`을 받아 세션 객체를 얻을 수 있습니다.
- `@SessionAttribute` 어노테이션을 사용하면 세션의 특정 속성을 파라미터로 직접 주입받아 코드를 더 간결하게 만들 수 있습니다.

---

## 3. 쿠키를 이용한 상태 관리

쿠키는 클라이언트(브라우저)에 작은 데이터를 저장하는 기술입니다. 서버는 이 쿠키를 읽어 사용자를 식별하거나 상태를 파악할 수 있습니다. 세션 방식도 클라이언트의 세션 ID를 식별하기 위해 `JSESSIONID`라는 쿠키를 사용합니다.

### 3.1. 쿠키 직접 다루기

'테마 설정', '오늘 하루 보지 않기' 기능처럼 서버의 저장 공간이 필요 없는 간단한 정보는 쿠키에 직접 저장하는 것이 효율적입니다.

**쿠키 생성하기 (`HttpServletResponse`)**:
컨트롤러에서 `HttpServletResponse` 객체의 `addCookie` 메서드를 사용하여 클라이언트에게 쿠키를 보낼 수 있습니다.

```java
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;

@GetMapping("/set-theme")
public String setTheme(HttpServletResponse response) {
    Cookie themeCookie = new Cookie("theme", "dark");
    themeCookie.setPath("/"); // 모든 경로에서 쿠키 사용
    themeCookie.setMaxAge(60 * 60 * 24 * 30); // 유효 기간: 30일

    response.addCookie(themeCookie);
    return "redirect:/";
}
```

**쿠키 읽기 (`@CookieValue`)**:
`@CookieValue` 어노테이션을 사용하면 특정 쿠키의 값을 간편하게 파라미터로 주입받을 수 있습니다.

```java
import org.springframework.web.bind.annotation.CookieValue;

@GetMapping("/")
public String home(@CookieValue(name = "theme", defaultValue = "light") String theme, Model model) {
    model.addAttribute("theme", theme);
    return "home";
}
```

이처럼 Spring MVC가 제공하는 기능을 활용하면 세션과 쿠키를 목적에 맞게 선택하여 상태 관리 로직을 손쉽게 구현할 수 있습니다.

---

## 1. 상태 유지(Stateful) vs 무상태(Stateless)

| 구분               | 상태 유지 (Stateful) - 세션 기반                                                                                                                                                                                                                                                                                        | 무상태 (Stateless) - 토큰 기반 (예: JWT)                                                                                                                                                                                                                                                                   |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **상태 저장 위치** | **서버** (메모리, DB, 외부 세션 스토리지 등)                                                                                                                                                                                                                                                                            | **클라이언트** (토큰 자체에 사용자 정보 포함)                                                                                                                                                                                                                                                              |
| **작동 방식**      | 1. 로그인 성공 시 서버가 **세션 ID**를 생성하고, 세션 저장소에 사용자 정보를 저장합니다.<br>2. 서버는 클라이언트에게 세션 ID를 쿠키(`JSESSIONID`)로 전달합니다.<br>3. 클라이언트는 이후 모든 요청에 세션 ID 쿠키를 담아 보냅니다.<br>4. 서버는 세션 ID를 통해 세션 저장소에서 사용자 정보를 조회하여 상태를 확인합니다. | 1. 로그인 성공 시 서버가 사용자 정보를 담은 **토큰**을 생성하고 서명합니다.<br>2. 서버는 토큰을 클라이언트에게 전달합니다.<br>3. 클라이언트는 이후 모든 요청의 헤더(예: `Authorization: Bearer ...`)에 토큰을 담아 보냅니다.<br>4. 서버는 토큰의 서명을 검증하여 사용자 정보를 신뢰하고 상태를 확인합니다. |
| **장점**           | - 중요한 사용자 정보(권한 등)를 서버에 안전하게 보관할 수 있습니다.<br>- 서버에서 특정 사용자의 세션을 강제로 만료시키는 등 세션 제어가 용이합니다.                                                                                                                                                                     | - 서버의 확장성(Scale-out)에 유리합니다. 각 서버가 상태를 저장할 필요가 없어 세션 동기화 문제가 발생하지 않습니다.<br>- 모바일 앱, 다른 도메인의 웹 서비스 등 다양한 클라이언트 환경에서 사용하기 편리합니다.                                                                                              |
| **단점**           | - 서버에 부하가 발생하고 추가적인 저장 공간이 필요합니다.<br>- 여러 서버로 확장할 경우, 모든 서버가 세션 정보를 공유해야 하는 **세션 동기화(Session Clustering)** 문제가 발생할 수 있습니다.                                                                                                                            | - 토큰에 담을 수 있는 정보의 양이 제한적입니다.<br>- 한 번 발급된 토큰은 만료 시간 전까지 제어하기 어렵습니다. (토큰을 강제 로그아웃 시키려면 서버 측에 별도의 블랙리스트 관리 필요)                                                                                                                       |

Spring Security는 이 두 가지 방식을 모두 지원하며, 전통적인 웹 애플리케이션에서는 세션 기반의 상태 유지 방식이 널리 사용됩니다.

---

## 2. Spring Security의 HTTP 세션 관리

Spring Security는 `SecurityFilterChain` 설정을 통해 세션 관리 정책을 손쉽게 제어할 수 있습니다.

### 2.1. `sessionManagement` DSL

`http.sessionManagement(...)` DSL을 사용하여 세션 생성 정책, 동시 접속 제어 등을 설정할 수 있습니다.

**설정 예시**:

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .sessionManagement(session -> session
            // 1. 세션 생성 정책 설정
            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
            // 2. 동시 세션 제어
            .maximumSessions(1)
                .maxSessionsPreventsLogin(true) // 새로운 로그인 차단
                .expiredUrl("/login?expired") // 세션 만료 시 이동할 URL
        );
    // ... 다른 설정 ...
    return http.build();
}
```

### 2.2. 세션 생성 정책 (`SessionCreationPolicy`)

- `IF_REQUIRED` (기본값): Spring Security가 필요하다고 판단할 때만 세션을 생성합니다. (예: 사용자가 로그인할 때)
- `ALWAYS`: 항상 세션을 생성합니다.
- `NEVER`: 세션을 생성하지 않지만, 이미 존재하는 세션은 사용합니다.
- `STATELESS`: **세션을 전혀 생성하지도, 사용하지도 않습니다.** JWT와 같은 토큰 기반의 무상태(Stateless) 인증을 구현할 때 반드시 이 정책으로 설정해야 합니다.

### 2.3. 로그아웃과 세션 무효화

사용자가 로그아웃을 하면, 해당 사용자와 연결된 세션은 더 이상 유효하지 않으므로 반드시 파기해야 합니다. `logout` DSL을 사용하면 이 과정이 자동으로 처리됩니다.

**로그아웃 설정 예시**:

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .logout(logout -> logout
            .logoutUrl("/logout") // 로그아웃을 처리할 URL
            .logoutSuccessUrl("/login?logout") // 로그아웃 성공 후 이동할 URL
            .invalidateHttpSession(true) // HTTP 세션을 무효화 (기본값: true)
            .deleteCookies("JSESSIONID") // 로그아웃 시 JSESSIONID 쿠키 삭제
        );
    // ... 다른 설정 ...
    return http.build();
}
```

- `invalidateHttpSession(true)`: 로그아웃 시 세션을 완전히 무효화하여 저장된 모든 속성을 제거합니다. 보안상 매우 중요한 설정입니다.

이처럼 Spring Security는 세션 기반의 상태 관리를 위한 강력하고 편리한 기능들을 제공하여, 개발자가 상태 유지 로직을 직접 구현하는 부담을 크게 줄여줍니다.

---

## 3. HTTP 세션 직접 다루기

Spring Security가 로그인 시 세션에 `SecurityContext`를 저장하는 등 많은 부분을 자동화하지만, '방문 횟수 추적'이나 '장바구니'처럼 애플리케이션 고유의 데이터를 세션에 직접 저장하고 싶을 때도 있습니다.

### 3.1. 세션에 데이터 저장 및 조회 (`HttpSession`)

컨트롤러 메서드에서 `HttpServletRequest`를 통해 `HttpSession` 객체를 얻거나, `HttpSession` 객체를 직접 파라미터로 받아 세션에 데이터를 저장(`setAttribute`)하거나 조회(`getAttribute`)할 수 있습니다.

**세션 사용 예시 (방문 횟수 추적)**:

```java
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class SessionController {

    @GetMapping("/visit")
    public String trackVisit(HttpServletRequest request, Model model) {
        // 세션 객체 가져오기 (없으면 새로 생성)
        HttpSession session = request.getSession(true);

        // 세션에서 "visitCount" 속성 가져오기
        Integer visitCount = (Integer) session.getAttribute("visitCount");

        if (visitCount == null) {
            visitCount = 1;
        } else {
            visitCount++;
        }

        // 변경된 방문 횟수를 세션에 다시 저장
        session.setAttribute("visitCount", visitCount);

        model.addAttribute("count", visitCount);
        return "visit-count"; // 방문 횟수를 표시할 뷰
    }
}
```

### 3.2. `@SessionAttribute`로 세션 속성 주입

`@SessionAttribute` 어노테이션을 사용하면 세션에서 특정 속성을 직접 파라미터로 주입받을 수 있어 코드가 더 간결해집니다.

**`@SessionAttribute` 사용 예시**:

```java
import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.SessionAttribute;

@Controller
public class SessionController {

    @GetMapping("/visit-v2")
    public String trackVisitV2(
        HttpSession session,
        // "visitCount" 세션 속성을 visitCount 파라미터에 주입
        // required = false: 해당 속성이 세션에 없어도 에러가 발생하지 않음 (null로 주입)
        @SessionAttribute(name = "visitCount", required = false) Integer visitCount,
        Model model
    ) {
        if (visitCount == null) {
            visitCount = 1;
        } else {
            visitCount++;
        }
        session.setAttribute("visitCount", visitCount);

        model.addAttribute("count", visitCount);
        return "visit-count";
    }
}
```

이처럼 Spring MVC가 제공하는 기능을 활용하면 세션과 별개로 쿠키를 직접 다루는 로직도 손쉽게 구현할 수 있습니다.
