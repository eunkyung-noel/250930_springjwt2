# 실전 예제 및 구성

지금까지 다룬 Spring Security의 핵심 개념들(인증, 인가, 세션, 예외 처리)을 종합하여 데이터베이스와 연동된 간단한 회원가입 및 로그인 기능을 구현하는 전체 과정을 살펴봅니다.

---

## 1. 프로젝트 의존성 추가 (`build.gradle`)

먼저 필요한 라이브러리들을 `build.gradle` 파일에 추가합니다.

```groovy
// build.gradle
plugins {
    id 'org.springframework.boot' version '3.2.5' // 예시 버전
    id 'io.spring.dependency-management' version '1.1.4'
    id 'java'
}

dependencies {
    // Spring Web: 웹 애플리케이션 개발을 위한 기본 의존성
    implementation 'org.springframework.boot:spring-boot-starter-web'

    // Spring Security: 보안 기능을 위한 핵심 의존성
    implementation 'org.springframework.boot:spring-boot-starter-security'

    // Thymeleaf: 서버 사이드 렌더링을 위한 템플릿 엔진
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'

    // Spring Data JPA: 데이터베이스 연동을 위한 의존성
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    // Lombok: @Getter, @Builder 등 보일러플레이트 코드를 줄여주는 라이브러리
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // H2 Database: 개발 및 테스트용 인메모리 데이터베이스
    runtimeOnly 'com.h2database:h2'
}
```

---

## 2. 사용자 엔티티 작성 (`UserAccount.java`)

데이터베이스의 `users` 테이블과 매핑될 `UserAccount` 엔티티입니다. Spring Security와 연동하기 위해 `UserDetails` 인터페이스를 구현합니다.

```java
// src/main/java/com/example/security/domain/UserAccount.java
package com.example.security.domain;

import jakarta.persistence.*;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor
public class UserAccount implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String password;

    private String role; // "USER", "ADMIN"

    @Builder
    public UserAccount(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + this.role));
    }

    // 나머지 UserDetails 메서드 구현 (isEnabled, isAccountNonExpired 등)
    // ... (이전 '인증' 문서의 예제 참고)
}
```

---

## 3. 리포지토리 작성 (`UserAccountRepository.java`)

Spring Data JPA를 사용하여 `UserAccount` 엔티티에 접근하기 위한 리포지토리 인터페이스입니다.

```java
// src/main/java/com/example/security/repository/UserAccountRepository.java
package com.example.security.repository;

import com.example.security.domain.UserAccount;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserAccountRepository extends JpaRepository<UserAccount, Long> {
    // 사용자 이름으로 사용자를 찾는 메서드 (로그인 시 사용)
    Optional<UserAccount> findByUsername(String username);
}
```

---

## 4. 서비스 계층 작성

### 4.1. `UserDetailsService` 구현 (`UserService.java`)

로그인 시 Spring Security가 호출하여 사용자 정보를 조회하는 서비스입니다.

```java
// src/main/java/com/example/security/service/UserService.java
package com.example.security.service;

import com.example.security.repository.UserAccountRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class UserService implements UserDetailsService {

    private final UserAccountRepository userAccountRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userAccountRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username));
    }
}
```

### 4.2. 회원가입 서비스 로직 (`UserAccountService.java`)

회원가입 요청을 처리하는 비즈니스 로직입니다. 비밀번호를 반드시 `PasswordEncoder`로 해싱하여 저장해야 합니다.

```java
// src/main/java/com/example/security/service/UserAccountService.java
package com.example.security.service;

import com.example.security.domain.UserAccount;
import com.example.security.repository.UserAccountRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class UserAccountService {

    private final UserAccountRepository userAccountRepository;
    private final PasswordEncoder passwordEncoder;

    @Transactional
    public Long register(String username, String password) {
        // 사용자 이름 중복 확인
        if (userAccountRepository.findByUsername(username).isPresent()) {
            throw new IllegalArgumentException("이미 사용 중인 사용자 이름입니다.");
        }

        // 비밀번호 해싱
        String encodedPassword = passwordEncoder.encode(password);

        UserAccount user = UserAccount.builder()
                .username(username)
                .password(encodedPassword)
                .role("USER") // 기본 역할 부여
                .build();

        return userAccountRepository.save(user).getId();
    }
}
```

---

## 5. 보안 설정 (`SecurityConfig.java`)

애플리케이션의 모든 보안 설정을 담당하는 핵심 클래스입니다.

```java
// src/main/java/com/example/security/config/SecurityConfig.java
package com.example.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                // 홈페이지, 로그인, 회원가입, 정적 리소스는 누구나 접근 가능
                .requestMatchers("/", "/login", "/register", "/css/**", "/js/**").permitAll()
                // '/my-page'는 'USER' 역할을 가진 사용자만 접근 가능
                .requestMatchers("/my-page").hasRole("USER")
                // 나머지 모든 요청은 인증된 사용자만 접근 가능
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login") // 커스텀 로그인 페이지
                .defaultSuccessUrl("/", true) // 로그인 성공 시 리다이렉트
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/") // 로그아웃 성공 시 리다이렉트
                .invalidateHttpSession(true) // 세션 무효화
            )
            .exceptionHandling(exception -> exception
                .accessDeniedPage("/access-denied") // 인가 실패 시
            );
        return http.build();
    }
}
```

---

## 6. 컨트롤러 및 뷰

마지막으로 사용자와 상호작용할 컨트롤러와 Thymeleaf 뷰 템플릿을 작성합니다.

- **`UserController`**: `/`, `/login`, `/register`, `/my-page` 등의 요청을 처리합니다.
- **`index.html`**: 메인 페이지
- **`login.html`**: 커스텀 로그인 폼. 로그인 실패 시 에러 메시지를 표시할 수 있습니다.
- **`registerForm.html`**: 회원가입 폼
- **`myPage.html`**: 로그인한 사용자만 접근 가능한 페이지

이 구성 요소들이 모여 하나의 완전한 회원가입 및 로그인 플로우를 형성합니다. 사용자가 회원가입 폼을 통해 정보를 제출하면 `UserAccountService`가 비밀번호를 해싱하여 DB에 저장하고, 로그인 폼을 통해 로그인을 시도하면 `UserService`(`UserDetailsService`)가 DB에서 사용자 정보를 조회하여 Spring Security가 인증을 수행합니다. 인증이 완료되면 `SecurityConfig`에 정의된 인가 규칙에 따라 페이지 접근이 제어됩니다.
