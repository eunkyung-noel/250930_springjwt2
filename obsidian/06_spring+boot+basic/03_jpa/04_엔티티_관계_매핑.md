# 엔티티 관계 매핑

관계형 데이터베이스의 핵심은 테이블 간의 관계입니다. JPA는 이러한 관계를 객체지향적으로 매핑할 수 있는 다양한 어노테이션을 제공합니다. 여기서는 가장 흔하게 사용되는 다대일(N:1)과 일대다(1:N) 관계를 중심으로 설명합니다.

## 1. 관계의 종류와 방향

- **방향**:
  - **단방향(Unidirectional)**: 한쪽 엔티티만 상대방을 참조하는 관계. (예: `Post` -> `User`)
  - **양방향(Bidirectional)**: 양쪽 엔티티가 서로를 참조하는 관계. (예: `Post` <-> `User`)
- **다중성(Multiplicity)**:
  - **다대일 (N:1, `@ManyToOne`)**: 여러 개의 자식 엔티티가 하나의 부모 엔티티에 연결. (예: 여러 `Post`가 하나의 `User`에 속함)
  - **일대다 (1:N, `@OneToMany`)**: 하나의 부모 엔티티가 여러 개의 자식 엔티티를 가짐. (예: 하나의 `User`가 여러 `Post`를 작성)
  - **일대일 (1:1, `@OneToOne`)**: 하나의 엔티티가 다른 엔티티 하나와만 연결.
  - **다대다 (N:N, `@ManyToMany`)**: 여러 엔티티가 다른 여러 엔티티와 연결. 실무에서는 중간에 연결 테이블을 만들어 두 개의 1:N 관계로 풀어내는 것을 권장합니다.

---

## 2. 다대일 (N:1) 단방향 매핑

가장 기본적이고 중요한 매핑입니다. **외래 키(Foreign Key)를 가진 쪽**이 관계의 주인이 됩니다. 예를 들어, `Post` 테이블이 `user_id`라는 외래 키를 가진다면, `Post` 엔티티가 `User` 엔티티를 참조해야 합니다.

- `@ManyToOne`: N:1 관계임을 명시합니다.
- `@JoinColumn(name = "...")`: 외래 키 컬럼의 이름을 지정합니다. 생략 시 JPA가 자동으로 이름을 생성합니다. (예: `user_id`)

```java
// domain/User.java
@Entity
@Table(name = "users") // DB 예약어 'user'와 충돌 방지
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    // User는 Post를 알지 못함 (단방향)
}

// domain/Post.java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @ManyToOne // Post(N) : User(1) 관계
    @JoinColumn(name = "user_id") // 외래 키 컬럼 이름 지정
    private User user; // 게시물 작성자 참조
}
```

이제 `Post`를 저장할 때 `User` 객체를 설정해주면, JPA가 자동으로 `user_id` 외래 키 값을 `Post` 테이블에 저장합니다.

---

## 3. 일대다 (1:N) 양방향 매핑

양방향 매핑은 양쪽 엔티티가 서로를 참조하는 관계입니다. 하지만 데이터베이스 테이블은 외래 키 하나로 관계를 표현하므로, JPA에서는 둘 중 하나를 **관계의 주인(Owner)**으로 정해야 합니다.

- **관계의 주인**: 외래 키를 관리하는 쪽. 보통 N쪽(`@ManyToOne`)이 주인이 됩니다.
- **주인이 아닌 쪽**: `mappedBy` 속성을 사용하여 관계의 주인이 아님을 명시하고, 주인의 필드 이름을 값으로 지정합니다. 이쪽에서는 외래 키를 변경할 수 없으며, 오직 조회만 가능합니다.

```java
// domain/User.java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    // 관계의 주인이 아님을 명시. Post 엔티티의 'user' 필드에 의해 매핑됨.
    @OneToMany(mappedBy = "user")
    private List<Post> posts = new ArrayList<>(); // 초기화 권장
}

// domain/Post.java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    // 관계의 주인. 외래 키(user_id)를 관리.
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    // 양방향 관계 편의 메서드
    public void setUser(User user) {
        this.user = user;
        user.getPosts().add(this); // 주인이 아닌 쪽의 컬렉션에도 추가
    }
}
```

> **양방향 관계 편의 메서드**
> 위 `Post.setUser()`처럼, 관계의 주인 쪽에서 값을 설정할 때 주인이 아닌 쪽의 컬렉션에도 데이터를 추가해주는 메서드를 만드는 것이 좋습니다. 이를 통해 객체 상태와 데이터베이스 상태의 불일치를 방지하고, JPA 영속성 컨텍스트와 상관없이 객체 그래프 탐색이 가능해집니다.

---

## 4. Fetch 전략: EAGER vs LAZY

JPA가 연관된 엔티티를 언제 데이터베이스에서 조회해올지를 결정하는 전략입니다. 성능에 매우 큰 영향을 미치므로 신중하게 선택해야 합니다.

- **`FetchType.EAGER` (즉시 로딩)**:

  - 주 엔티티를 조회할 때 연관된 엔티티도 **항상 함께** 조회합니다. (SQL JOIN 사용)
  - `@ManyToOne`, `@OneToOne`의 기본값입니다.
  - **단점**: 사용하지도 않을 연관 엔티티까지 조회하여 성능 저하를 유발할 수 있습니다. 특히 여러 관계가 즉시 로딩으로 얽혀있으면 예상치 못한 대규모 쿼리가 발생할 수 있습니다.

- **`FetchType.LAZY` (지연 로딩)**:
  - 주 엔티티를 조회할 때는 연관된 엔티티를 가져오지 않고, 프록시(Proxy) 객체로 채워둡니다.
  - 연관된 엔티티를 **실제로 사용하는 시점**(예: `post.getUser().getUsername()`)에 비로소 조회 쿼리가 실행됩니다.
  - `@OneToMany`, `@ManyToMany`의 기본값입니다.

> **성능을 위한 Best Practice**
>
> - **모든 연관 관계는 `FetchType.LAZY`로 설정하는 것을 원칙으로 합니다.**
>   - `@ManyToOne(fetch = FetchType.LAZY)`
>   - `@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)`
> - 즉시 로딩이 꼭 필요한 경우에는 JPQL의 **Fetch Join**이나 `@EntityGraph`를 사용하여 특정 쿼리에서만 명시적으로 함께 조회하도록 합니다.

---

## 5. N+1 문제와 해결

지연 로딩(LAZY)을 사용하더라도 **N+1 문제**가 발생할 수 있습니다.

- **문제 상황**:
  1. `List<Post>`를 조회 (쿼리 1번)
  2. 조회된 `Post`가 N개일 때, 각 `Post`의 작성자(`post.getUser()`)를 루프 안에서 조회 (쿼리 N번)
  - **총 1 + N번의 쿼리가 실행되어 심각한 성능 저하 발생!**

### 해결 방안

#### 5.1. Fetch Join

JPQL에서 `JOIN FETCH` 키워드를 사용하여, 조회 시 연관된 엔티티를 함께 가져오도록 명시합니다.

```java
// PostRepository.java
@Query("SELECT p FROM Post p JOIN FETCH p.user")
List<Post> findAllWithUser();
```

이 쿼리는 처음부터 `Post`와 `User`를 JOIN하여 한 번의 쿼리로 모든 데이터를 가져옵니다.

#### 5.2. `@EntityGraph`

JPQL을 수정하지 않고, 어노테이션을 통해 함께 조회할 연관 엔티티를 지정할 수 있습니다.

```java
// PostRepository.java
@Override
@EntityGraph(attributePaths = {"user"}) // 'user' 필드를 함께 조회
List<Post> findAll();
```

`findAll()` 메서드를 호출하면 `user` 정보까지 JOIN하여 가져옵니다.

#### 5.3. 배치 사이즈 (Batch Size)

`application.yml`에 `default_batch_fetch_size`를 설정하면, 지연 로딩 시 여러 엔티티를 한 번에 모아서 `IN` 절로 조회해줍니다.

```yaml
# application.yml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100 # 100개씩 모아서 IN 쿼리 실행
```

N+1 문제를 1+1 문제로 완화시켜주는 효과적인 방법입니다. Fetch Join이나 `@EntityGraph`를 적용하기 애매한 경우에 전역적으로 설정해두면 좋습니다.
