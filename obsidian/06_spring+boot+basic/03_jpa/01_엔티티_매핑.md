# 엔티티 매핑

엔티티(Entity)는 데이터베이스의 테이블에 대응되는 자바 클래스입니다. JPA는 `@Entity` 어노테이션이 붙은 클래스를 관리하며, 이 클래스의 인스턴스는 테이블의 레코드 하나에 해당합니다.

## 1. `@Entity`와 기본 매핑

- `@Entity`: 이 클래스가 JPA 관리 대상임을 나타냅니다.
- `@Table(name = "...")`: 매핑할 테이블의 이름을 지정합니다. 생략하면 클래스 이름을 테이블 이름으로 사용합니다.
- **기본 생성자**: JPA는 엔티티 객체를 생성할 때 기본 생성자를 사용하므로, **파라미터가 없는 기본 생성자**가 반드시 필요합니다. 접근 제어자는 `public` 또는 `protected`를 사용해야 합니다. (`protected` 권장)

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity // 이 클래스는 JPA가 관리하는 엔티티입니다.
@Getter
@NoArgsConstructor(access = lombok.AccessLevel.PROTECTED) // JPA를 위한 기본 생성자 (protected)
public class Member {

    @Id // Primary Key
    private Long id;

    private String name;

    public Member(String name) {
        this.name = name;
    }
}
```

> **Lombok과 엔티티**
>
> - `@Getter`: 필드 값을 조회하는 Getter 메서드를 생성합니다.
> - `@Setter`: 필드 값을 변경하는 Setter 메서드를 생성합니다. 하지만 엔티티의 일관성을 해칠 수 있으므로 무분별한 사용은 지양하고, 필요한 경우에만 선별적으로 사용하거나 **변경 목적이 명확한 비즈니스 메서드(예: `update(...)`)**를 만드는 것이 좋습니다.
> - `@NoArgsConstructor(access = AccessLevel.PROTECTED)`: JPA 명세를 만족하는 `protected` 기본 생성자를 만듭니다.
> - `@Data`: `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode` 등을 모두 포함하므로 매우 편리하지만, 엔티티 클래스에는 **사용을 지양**해야 합니다. 예측하지 못한 동작(특히 `@ToString`의 순환 참조, `@EqualsAndHashCode`의 프록시 문제)을 유발할 수 있습니다.

---

## 2. 기본 키(Primary Key) 매핑

모든 엔티티는 테이블의 기본 키에 해당하는 필드를 가져야 하며, `@Id` 어노테이션으로 지정합니다. 기본 키 값은 JPA가 자동으로 생성하도록 설정할 수 있습니다.

- `@Id`: 해당 필드가 기본 키임을 명시합니다.
- `@GeneratedValue`: 기본 키 값을 자동으로 생성하는 전략을 지정합니다.

### `strategy` 속성

- `GenerationType.IDENTITY`: 데이터베이스의 `AUTO_INCREMENT` 또는 `IDENTITY` 컬럼을 사용하여 키를 생성합니다. (예: MySQL, H2) 데이터베이스에 레코드가 `INSERT`된 후에야 기본 키 값을 알 수 있습니다.
- `GenerationType.SEQUENCE`: 데이터베이스 시퀀스 객체를 사용하여 키를 생성합니다. (예: Oracle, PostgreSQL)
- `GenerationType.AUTO`: 사용하는 데이터베이스 방언(Dialect)에 따라 위 전략 중 하나를 자동으로 선택합니다. (기본값)
- `GenerationType.UUID`: Hibernate 6부터 지원하며, UUID를 기본 키로 사용합니다. 분산 환경에서 중복 없이 고유한 키를 생성할 수 있습니다.

```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import java.util.UUID;

@Entity
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // MySQL의 AUTO_INCREMENT 사용
    private Long id;

    // ...
}

@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID) // UUID 사용
    private UUID id;

    // ...
}
```

---

## 3. 필드-컬럼 매핑

엔티티의 필드는 기본적으로 테이블의 컬럼과 매핑됩니다. `@Column` 어노테이션을 사용하여 세부 속성을 지정할 수 있습니다.

- `@Column`:
  - `name`: 매핑할 컬럼의 이름을 지정합니다. (기본값: 필드 이름)
  - `nullable`: `false`로 설정 시 `NOT NULL` 제약조건이 추가됩니다. (기본값: `true`)
  - `unique`: `true`로 설정 시 `UNIQUE` 제약조건이 추가됩니다.
  - `length`: 문자열 타입 컬럼의 길이를 지정합니다. (기본값: `255`)
  - `columnDefinition`: 컬럼 타입을 직접 지정할 때 사용합니다. (예: `TEXT`, `VARCHAR(1000)`)

```java
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class Post {

    @Id
    private Long id;

    @Column(name = "post_title", nullable = false, length = 500)
    private String title;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    @Column(unique = true)
    private String slug; // 고유한 URL 경로
}
```

---

## 4. 공통 필드 관리 (Auditing)

대부분의 테이블은 생성일(`createdAt`), 수정일(`updatedAt`)과 같은 공통 필드를 가집니다. JPA의 Auditing 기능을 사용하면 이러한 필드를 자동으로 관리할 수 있습니다.

### 4.1. `@EnableJpaAuditing` 활성화

애플리케이션의 메인 클래스에 `@EnableJpaAuditing` 어노테이션을 추가하여 Auditing 기능을 활성화합니다.

```java
// JpaApplication.java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@EnableJpaAuditing // JPA Auditing 기능 활성화
@SpringBootApplication
public class JpaApplication {
    public static void main(String[] args) {
        SpringApplication.run(JpaApplication.class, args);
    }
}
```

### 4.2. 공통 필드 추상 클래스 생성

- `@MappedSuperclass`: 이 클래스는 테이블과 직접 매핑되지 않고, 상속하는 자식 엔티티에게 필드만 물려주는 역할을 합니다.
- `@EntityListeners(AuditingEntityListener.class)`: 해당 엔티티에 Auditing 기능을 적용합니다.
- `@CreatedDate`: 엔티티가 생성될 때의 시간을 자동으로 저장합니다.
- `@LastModifiedDate`: 엔티티가 수정될 때의 시간을 자동으로 저장합니다.

```java
// domain/BaseTimeEntity.java
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
import java.time.LocalDateTime;

@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseTimeEntity {

    @CreatedDate
    @Column(updatable = false) // 생성 시간은 수정되지 않도록 설정
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
}
```

### 4.3. 엔티티에 상속 적용

이제 `BaseTimeEntity`를 상속받기만 하면 `createdAt`과 `updatedAt` 필드가 자동으로 관리됩니다.

```java
@Entity
public class Post extends BaseTimeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String content;

    // createdAt, updatedAt 필드는 BaseTimeEntity로부터 상속받음
}
```
